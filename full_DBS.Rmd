---
title: "DBS_all_solvent"
author: "Philippine Louail"
date: "2024-04-22"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# intro 

```{r packages, message=FALSE, warning=FALSE}
library(MsExperiment)
library(xcms)
library(Spectra)
library(RColorBrewer)
library(pander)
library(readxl)
library(MetaboCoreUtils)
library(pheatmap)
library(MsBackendSql)
library(readxl)
library(Biobase)
library(SummarizedExperiment)
library(openxlsx)
```

```{r parallel-process}
#' Set up parallel processing using 2 cores
if (.Platform$OS.type == "unix") {
    register(MulticoreParam(2))
} else
    register(SnowParam(2))
```

# Introduction

Here I will evaluate the effect of different solvent used for extraction and 
their effect on the metabolite profile of the samples. 

I separate the datasets by devices and I will have one Rmd file for each.

This markdown is for the DBS device.
I will compare the results between the solvent throughout the analysis.

```{r load_data}
#' No Phenodata - to be added
MZML_PATH <- getwd()
pd <- read_xls("phenodata.xls") |>
    as.data.frame()

full <- readMsExperiment(paste0(MZML_PATH, "/", pd$file), sampleData = pd)
full

sampleData(full)|> 
  as.data.frame() |>
  pandoc.table(style = "simple", caption = "Samples from the data set.")
```

#DBS 

This dataset recorded both DBS and VAMS so I will filter the data to only keep
the DBS samples. 

```{r}
# Extract each sovent of DBS
full <- full[sampleData(full)$sample_type == "DBS"]
sampleData(full) |> 
  as.data.frame() |>
  pandoc.table(style = "simple", caption = "Samples from the data set.")

dir <- "DBS_results/full/"
dir.create(dir, recursive = TRUE, showWarnings = FALSE)
```

```{r quick-checks}
 #' Retention time range for entire dataset 
spectra(full) |>
rtime() |>
range()

# Check number of samples 
length(full)

#' Check Ms level
spectra(full) |> 
    msLevel() |>
    split(fromFile(full)) |>
    lapply(table)
```

```{r}
#' Define colors for the different sample role
leg_sample <- brewer.pal(8, name = "Dark2")[c(2, 8)]
names(leg_sample) <- unique(sampleData(full)$sample_role)
col_sample <- leg_sample[sampleData(full)$sample_role]

#' Define colors for the differen solvent
leg_solvent <- brewer.pal(8, name = "Dark2")[c(3, 5, 6, 7)]
names(leg_solvent) <- unique(sampleData(full)$solvent)
col_solvent <- leg_solvent[sampleData(full)$solvent]
```

```{r plot_bpc}
#' First extract and plot bpc 
bpc <- chromatogram(full, aggregationFun = "max", msLevel = 1, chunkSize = 2)

plot(bpc, main = "BPC", col = col_sample, 
                    lwd = 1)
grid()
legend("topright", col = leg_sample,
       legend = names(leg_sample), lty = 1, horiz = TRUE, bty = "n")
```

BPC comments: 
there seem to be contamination throughout the entire RT range but especially 
after 500s.

I import a known compound list (curation of annotated ions from MsDial using 
HMDB database).
I them extract eics for each compound and evaluate them regarding: 

- peak shape, width
- intensity vairation related to sample-type,... 
- retention time variation

```{r include=FALSE}
#import known_compound list 
compounds <- read_xlsx("Annotation_List.xlsx") |>
    as.data.frame()

# plot eic and coloring per solvent - see if I need to extend rtmin and rtmax 
# full
eics <- chromatogram(
    full,
    rt = as.matrix(compounds[, c("rtmin", "rtmax")]),
    mz = as.matrix(compounds[, c("mzmin", "mzmax")]), msLevel = 1, chunkSize = 2)

fData(eics)$mz <- compounds$Average_Mz
fData(eics)$rt <- compounds$Average_Rt
fData(eics)$name <- compounds$Metabolite_Name
rownames(eics) <- compounds$Metabolite_Name

tmpdr <- paste0(dir, "raw/")
dir.create(tmpdr, recursive = TRUE, showWarnings = FALSE)
for (i in seq_len(nrow(compounds))) {
    png(paste0(tmpdr, "EIC_", fData(eics)$name[i], ".png"),
        width = 12, height = 8, units = "cm", res = 600, pointsize = 4)
    plot(eics[i, ], main = fData(eics)$name[i],
         col = paste0(col_sample, 80))
    grid()
    legend("topright", col = leg_sample,
           legend = names(leg_sample), lty = 1)
    abline(v = fData(eics)$rt[i], col = "red", lty = 3)
    dev.off()
}
```

There is wide intensity variation between the study samples. Not related to 
solvents.

# preprocessing

The parameters for peack picking are based on previous data that I received and
tested using the list of known compounds given by the laboratory

```{r}
#' Peakpicking
param <- CentWaveParam(peakwidth = c(10, 20), ppm = 50, integrate = 2, 
                       snthresh = 5, extendLengthMSW = TRUE)

full <- findChromPeaks(full, param = param, chunkSize = 2L)
```

Again i will plot the EICs to observe how well the peak picking went.

```{r eic2, include=FALSE}
#full
eics <- chromatogram(
    full,
    rt = as.matrix(compounds[, c("rtmin", "rtmax")]),
    mz = as.matrix(compounds[, c("mzmin", "mzmax")]),
    msLevel = 1,
    chunkSize = 2)

fData(eics)$mz <- compounds$Average_Mz
fData(eics)$rt <- compounds$Average_Rt
fData(eics)$name <- compounds$Metabolite_Name
rownames(eics) <- compounds$Metabolite_Name

tmpdr <- paste0(dir, "chrompeaks/")
dir.create(tmpdr, recursive = TRUE, showWarnings = FALSE)
for (i in seq_len(nrow(compounds))) {
    png(paste0(tmpdr, "EIC_", fData(eics)$name[i], ".png"),
        width = 12, height = 8, units = "cm", res = 600, pointsize = 4)
    plot(eics[i, ], main = fData(eics)$name[i],
         col = paste0(col_sample, 80),
         peakBg = paste0(col_sample, 40)[chromPeaks(eics[i])[, "column"]])
    grid()
    legend("topright", col = leg_sample,
           legend = names(leg_sample), lty = 1)
    abline(v = fData(eics)$rt[i], col = "red", lty = 3)
    dev.off()
}
```

Refinement: merge neighboring peaks. Remove artifacts that can be created
during peak picking. especially necessary when not enough MS1 data point (which 
is the cases here for some peaks)

```{r}
param <- MergeNeighboringPeaksParam(expandRt = 10,
                                    expandMz = 0.01,
                                    ppm = 10,
                                    minProp = 0.75)

full <- refineChromPeaks(full, param = param, chunkSize = 2)

chromPeakData(full)$merged |>
                      table()
```

```{r include=FALSE}
eics <- chromatogram(
    full,
    rt = as.matrix(compounds[, c("rtmin", "rtmax")]),
    mz = as.matrix(compounds[, c("mzmin", "mzmax")]),
    msLevel = 1,
    chunkSize = 2)

fData(eics)$mz <- compounds$Average_Mz
fData(eics)$rt <- compounds$Average_Rt
fData(eics)$name <- compounds$Metabolite_Name
rownames(eics) <- compounds$Metabolite_Name

tmpdr <- paste0(dir, "refine/")
dir.create(tmpdr, recursive = TRUE, showWarnings = FALSE)
for (i in seq_len(nrow(compounds))) {
    png(paste0(tmpdr, "EIC_", fData(eics)$name[i], ".png"),
        width = 12, height = 8, units = "cm", res = 600, pointsize = 4)
    plot(eics[i, ], main = fData(eics)$name[i],
         col = paste0(col_sample, 80),
         peakBg = paste0(col_sample, 40)[chromPeaks(eics[i])[, "column"]])
    grid()
    legend("topright", col = leg_sample,
           legend = names(leg_sample), lty = 1)
    abline(v = fData(eics)$rt[i], col = "red", lty = 3)
    dev.off()
}
```

Alignment: Very little variation in RT between samples, but always good to run
it. 

```{r}
#' perform quick correspondence analysis - do not take in account Blanks
f <- factor(sampleData(full)$solvent, 
            levels = unique(sampleData(full)$solvent))
idx_B <- sampleData(full)$sample_role == "Blank"
f[idx_B] <- NA

param <- PeakDensityParam(sampleGroups = f,
                          minFraction = 1, 
                          binSize = 0.01, ppm = 10,
                          bw = 2)

full <- groupChromPeaks(full, param = param)

#' align the data 
param <- PeakGroupsParam(minFraction = 0.75, extraPeaks = 50, span = 0.5)

#' Input in the function
full <- adjustRtime(full, param = param)

#' See retention time variation
plotAdjustedRtime(full, col = paste0(col_sample, 80), peakGroupsPch = 1)
grid()
legend("topright", col = leg_sample,
       legend = names(leg_sample), lty = 1, bty = "n")

full <- applyAdjustedRtime(full)
```

```{r include=FALSE}
eics <- chromatogram(
    full,
    rt = as.matrix(compounds[, c("rtmin", "rtmax")]),
    mz = as.matrix(compounds[, c("mzmin", "mzmax")]),
    msLevel = 1,
    chunkSize = 2)

fData(eics)$mz <- compounds$Average_Mz
fData(eics)$rt <- compounds$Average_Rt
fData(eics)$name <- compounds$Metabolite_Name
rownames(eics) <- compounds$Metabolite_Name

tmpdr <- paste0(dir, "aligned/")
dir.create(tmpdr, recursive = TRUE, showWarnings = FALSE)
for (i in seq_len(nrow(compounds))) {
    png(paste0(tmpdr, "EIC_", fData(eics)$name[i], ".png"),
        width = 12, height = 8, units = "cm", res = 600, pointsize = 4)
    plot(eics[i, ], main = fData(eics)$name[i],
         col = paste0(col_sample, 80),
         peakBg = paste0(col_sample, 40)[chromPeaks(eics[i])[, "column"]])
    grid()
    legend("topright", col = leg_sample,
           legend = names(leg_sample), lty = 1)
    abline(v = fData(eics)$rt[i], col = "red", lty = 3)
    dev.off()
}
```

Correspondence step: 
Define features, here we define a feature  if there are at least 2 out of
three of a triplicate for at least one solvent. 
we also separate the blanks so that they don't interfere with peak picking, 
important here as we have a lot of signal in blanks. 

```{r}
# correspondence - use same factor as before
param <- PeakDensityParam(sampleGroups = f,
                        minFraction = 2/3, binSize = 0.015, bw = 2.0, ppm = 10) 

plotChromPeakDensity(
    eics["1_18_1_lysophosphatidylcholine"], param = param,
    col = paste0(col_sample, "80"),
    peakCol = col_sample[
        chromPeaks(eics["1_18_1_lysophosphatidylcholine"])[, "column"]],
    peakBg = paste0(col_sample[
        chromPeaks(eics["1_18_1_lysophosphatidylcholine"])[, "column"]], 20),
    peakPch = 16)

plotChromPeakDensity(eics["LysoPhosphatidylcholine_16_0"], param = param,
    col = paste0(col_sample, "80"),
    peakCol = col_sample[
        chromPeaks(eics["LysoPhosphatidylcholine_16_0"])[, "column"]],
    peakBg = paste0(
        col_sample[chromPeaks(
            eics["LysoPhosphatidylcholine_16_0"])[, "column"]], 20),
    peakPch = 16)

# the tests look great, lets apply to entire dataset
full <- groupChromPeaks(full, param = param)

# how many features:
nrow(featureDefinitions(full))
```

gap filling helps rescue signal. Here solvent might influence eachother and it 
is impossible to prevent that. 
later down we can change the data chosen as to not use this filling if we 
believe this is influencing the results too  much. This NOT a mandatory step, 
but it will be always run in a normal analysis as it usually saves a LOT of 
signal.

```{r}
#' gap filing
#' Number of missing values
sum(is.na(featureValues(full)))

full <- fillChromPeaks(full, param = ChromPeakAreaParam(), chunkSize = 2)

#' How many missing values after
sum(is.na(featureValues(full)))
```

Extract the intensity values for the features and save the data. 

```{r}
#' Extract results as a SummarizedExperiment
library(SummarizedExperiment)

res_full <- quantify(full, method = "sum", filled = FALSE)
assays(res_full)$raw_filled <- featureValues(full, method = "sum",
                                        filled = TRUE )
```

Save files at the end of preprocessing

```{r}
save(res_full, file = paste0(dir, "SumExp_full_preprocessing.RData"))
save(full, file = paste0(dir, "full_preprocessing.RData"))
load(paste0(dir, "full_preprocessing.RData"))
```

# Normalisation 

```{r extra-packages, message=FALSE, warning=FALSE}
library(ggfortify)
library(SummarizedExperiment)
library(RColorBrewer)

idx_blank <- sampleData(full)$sample_role == "Blank"
leg_solvent <- brewer.pal(8, name = "Dark2")[c(3, 5, 6, 7)]
names(leg_solvent) <- unique(sampleData(full)$solvent)
col_solvent <- leg_solvent[sampleData(full)$solvent[!idx_blank]]
```

We first need to evaluate the data distribution and try to see any technical
related bias.

```{r counts1, fig.height=5, fig.width=5, include=TRUE}
layout(mat = matrix(1:3, ncol = 1), height = c(0.2, 0.2, 0.8))

par(mar = c(0.2, 4.5, 0.2, 3))
barplot(apply(assay(res_full, "raw")[,!idx_blank], MARGIN = 2, 
              function(x) sum(!is.na(x))),
        col = col_solvent, ylab = "features raw data", xaxt = "n", 
        space = 0.012)
barplot(apply(assay(res_full, "raw_filled")[,!idx_blank], MARGIN = 2, 
              function(x) sum(!is.na(x))),
        col = col_solvent, ylab = "features filled data", xaxt = "n", 
        space = 0.012)
boxplot(log2(assay(res_full, "raw_filled")[,!idx_blank]), xaxt = "n",
        ylab = expression(log[2]~abundance~filled~data),
        col = col_solvent, outline=FALSE, medlty = "blank", 
        border = col_solvent, varwidth = TRUE)
points(colMedians(log2(assay(res_full, "raw_filled")[,!idx_blank]), 
                  na.rm = TRUE), type = "b", pch = 16) 
grid(nx = NA, ny = NULL)
legend("topright", col = leg_solvent,
       legend = names(leg_solvent), lty=1, lwd = 2, xpd = TRUE, ncol = 4, 
       cex = 0.8,  bty = "n")
```

```{r rla-plot raw and filled1, fig.cap = "RLA plot for the raw data and filled data. Note: outliers are not drawn."}
par(mfrow = c(1, 1), mar = c(0.2, 4.5, 2.5, 3))
boxplot(rowRla(assay(res_full, "raw_filled")[, !idx_blank],
               group = res_full$solvent[!idx_blank]),
        cex = 0.5, pch = 16, boxwex = 1,
        col = col_solvent, ylab = "RLA",
        border = paste0(col_solvent, 40),
        outline = FALSE, xaxt = "n", main = "Relative log abundance", 
        cex.main = 1)
grid(nx = NA, ny = NULL)
abline(h = 0, lty=3, lwd = 1, col = "black")
legend("topright", col = leg_solvent,
       legend = names(leg_solvent), lty=1, lwd = 2, xpd = TRUE, ncol = 3,
       cex = 0.8,  bty = "n")
```

It is important to note that for this dataset the samples were not randomized.
there the order of plotting above is the injection index order too. 
We can see a clear, injection related bias in the dataset. We will run a median
scaling step to see how well we can correct the variation between samples.

## quick median scaling

```{r}
#' Compute median and generate normalization factor, we all compute together, 
#' they are part of the same experiment as we believe the same technical 
#' variance is applied here

blank_idx <- res_full$sample_role != "Blank"
mdns <- apply(assay(res_full, "raw_filled"), MARGIN = 2, median, na.rm = TRUE)
nf_mdn <- mdns / median(mdns[blank_idx]) # To not take blank data in account
assays(res_full)$norm <- sweep(assay(res_full, "raw_filled"), MARGIN = 2, 
                               nf_mdn, '/')
```

We also do not use the median from blank samples as we don't want them to 
influence our study samples. Because we separated the blanks when defining the
features (correspondence step) we will have much *less* features in blanks and 
therefore the intensity distribution for these is not reliable. 

```{r rla-plot after norm2, include = TRUE, fig.cap = "RLA plot before and after normalization. Note: outliers are not drawn.", fig.height= 7, fig.width=5.5}
par(mfrow = c(2, 1), mar = c(1, 4, 3, 1))

boxplot(rowRla(assay(res_full, "raw_filled")[, !idx_blank],
               group = res_full$solvent[!idx_blank]),
        cex = 0.5, pch = 16, boxwex = 1,
        col = col_solvent, ylab = "RLA",
        border = paste0(col_solvent, 40),
        outline = FALSE, xaxt = "n", 
        main = "Relative log abundance before normalisation", 
        cex.main = 1)
grid(nx = NA, ny = NULL)
abline(h = 0, lty=3, lwd = 1, col = "black")
legend("topright", col = leg_solvent,
       legend = names(leg_solvent), lty=1, lwd = 2, xpd = TRUE, ncol = 3,
       cex = 0.8,  bty = "n")
boxplot(rowRla(assay(res_full, "norm")[, !idx_blank],
               group = res_full$solvent[!idx_blank]),
        cex = 0.5, pch = 16, boxwex = 1,
        col = col_solvent, ylab = "RLA",
        border = paste0(col_solvent, 40),
        outline = FALSE, xaxt = "n", 
        main = "Relative log abundance after normalization",
        cex.main = 1, ylim = c(-1.0 , 2.0))
grid(nx = NA, ny = NULL)
abline(h = 0, lty=3, lwd = 1, col = "black")
legend("topright", col = leg_solvent,
       legend = names(leg_solvent), lty=1, lwd = 2, xpd = TRUE, ncol = 3,
       cex = 0.8,  bty = "n")
```

## Coeffcient of variation

The coefficient of variation (or Relativa standanrd deviation) evaluate how 
close data is to each other. It is especially intereesting in our case as we
have triplicate. 
Therefore here we compute the RSD for each feature across the samples in each
solvent.

The  RSD table below therefore give us an information on how the triplicate are
close to eachother overall per solvent. 

```{r include=TRUE, results = "asis"}
# indices of each solvents' triplicates
idx_mh  <- res_full$solvent == "MEOH_H2O" & res_full$sample_role != "Blank"
idx_m  <- res_full$solvent == "MEOH" & res_full$sample_role != "Blank"
idx_a  <- res_full$solvent == "ACN" & res_full$sample_role != "Blank"
idx_am <- res_full$solvent == "ACN_MEOH" & res_full$sample_role != "Blank"

# Compute Rsds on  all data per solvents
sample_res <- cbind(
    Raw_MH = rowRsd(assay(res_full, "raw_filled")[, idx_mh],
                    na.rm = TRUE, mad = TRUE),
    Norm_MH = rowRsd(assay(res_full, "norm")[, idx_mh],
                     na.rm = TRUE, mad = TRUE),
    Raw_M = rowRsd(assay(res_full, "raw_filled")[, idx_m],
                   na.rm = TRUE, mad = TRUE),
    Norm_M = rowRsd(assay(res_full, "norm")[, idx_m],
                    na.rm = TRUE, mad = TRUE),
    Raw_A = rowRsd(assay(res_full, "raw_filled")[, idx_a],
                   na.rm = TRUE, mad = TRUE),
    Norm_A = rowRsd(assay(res_full, "norm")[, idx_a],
                    na.rm = TRUE, mad = TRUE),
    Raw_AM = rowRsd(assay(res_full, "raw_filled")[, idx_am],
                    na.rm = TRUE, mad = TRUE),
    Norm_AM = rowRsd(assay(res_full, "norm")[, idx_am],
                     na.rm = TRUE, mad = TRUE)
)

#' Compute quantile for better data visualisation
res_df <- data.frame(
    Raw_MH = quantile(sample_res[, "Raw_MH"], na.rm = TRUE),
    Norm_MH = quantile(sample_res[, "Norm_MH"], na.rm = TRUE),
    Raw_M = quantile(sample_res[, "Raw_M"], na.rm = TRUE),
    Norm_M = quantile(sample_res[, "Norm_M"], na.rm = TRUE),
    Raw_A = quantile(sample_res[, "Raw_A"], na.rm = TRUE),
    Norm_A = quantile(sample_res[, "Norm_A"], na.rm = TRUE),
    Raw_AM = quantile(sample_res[, "Raw_AM"], na.rm = TRUE),
    Norm_AM = quantile(sample_res[, "Norm_AM"], na.rm = TRUE)
    
)
cpt <- paste0("Distribution of RSD values across samples for the raw and ",
              "normalized data.")
pandoc.table(res_df, style = "rmarkdown", caption = cpt)
```

Both the RLA plot and the CV values show that the normalization step was
successful. The RLA shows all samples median got closer to each other and 75% 
of our features have a CV below 30%  for each solvent which is great. 

## quick blank flagging

We flag features that have a high intensity in the blanks. 
(e.g. more than half the average of the study samples)

```{r}
idx <- res_full$sample_role == "Blank"
full <- filterFeatures(full, BlankFlag(blankIndex = idx, qcIndex = !idx))
```

Lots of flags

# Comparison on overall data

- Contamination flag: comparing the amount of features that are flagged as
possible contamination from the solvent.

```{r}
fts_def <- featureDefinitions(full)[, c("MEOH_H2O", "MEOH", "ACN", "ACN_MEOH", 
                                        "possible_contaminants")]
fts_def$possible_contaminants[is.na(fts_def$possible_contaminants)] <- FALSE
fts_def$possible_contaminants <- as.logical(fts_def$possible_contaminants)

MEOH <- fts_def$MEOH >= 2 & fts_def$possible_contaminants == TRUE
MEOH_H2O <- fts_def$MEOH_H2O >= 2 & fts_def$possible_contaminants == TRUE
ACN <- fts_def$ACN >= 2 & fts_def$possible_contaminants == TRUE
ACN_MEOH <- fts_def$ACN_MEOH >= 2 & fts_def$possible_contaminants == TRUE

# Summary compare amount of cont. between solvent
list_cont <- c(sum(MEOH_H2O), sum(ACN), sum(MEOH), sum(ACN_MEOH))

# Create the bar plot
barplot(list_cont,
        names.arg = names(leg_solvent),
        col = leg_solvent,
        xlab = "Solvents",
        ylab = "Number of  features",
        main = paste0("Number of features that are flagged as possible ",
                      "contamination from solvent"))
```

- summary plot: the plot below is one of the summary plot that compare results
after prepossessing and normalization.

```{r fig.height=8, fig.width=6}
# Define the number of features for each solvent (both flagged and non-flagged)
MEOH_H2O <- featureDefinitions(full)$MEOH_H2O >= 2
ACN <- featureDefinitions(full)$ACN >= 2
MEOH <- featureDefinitions(full)$MEOH >= 2
ACN_MEOH <- featureDefinitions(full)$ACN_MEOH >= 2

num_features <- c(sum(MEOH_H2O), sum(ACN), sum(MEOH), sum(ACN_MEOH))

#' Quantile of RSD values after norm
res_df <- data.frame(
    MetOH_H2O = quantile(sample_res[, "Norm_MH"], na.rm = TRUE),
    ACN = quantile(sample_res[, "Norm_A"], na.rm = TRUE),
    MetOH = quantile(sample_res[, "Norm_M"], na.rm = TRUE),
    ACN_MetOH = quantile(sample_res[, "Norm_AM"], na.rm = TRUE)
    
)

# Intensity and missing values 

res_mh <- res_full[, res_full$solvent == "MEOH_H2O"]
res_m <- res_full[, res_full$solvent == "MEOH"]
res_a <- res_full[, res_full$solvent == "ACN"]
res_am <- res_full[, res_full$solvent == "ACN_MEOH"]

intensity <- cbind(
    MetOH_H2O = log2(as.numeric(assay(res_mh, "norm"))),
    ACN = log2(as.numeric(assay(res_a, "norm"))),
    MetOH = log2(as.numeric(assay(res_m, "norm"))),
    AVN_MetOH = log2(as.numeric(assay(res_am, "norm"))))

missing_values <- cbind(
    MetOH_H2O = rowSums(is.na(assay(res_mh, "raw"))),
    ACN = rowSums(is.na(assay(res_a, "raw"))),
    MetOH = rowSums(is.na(assay(res_m, "raw"))),
    ACN_MetOH = rowSums(is.na(assay(res_am, "raw"))))

#General plot

layout(mat = matrix(1:3, ncol = 1), height = c(0.3, 0.3, 0.8))
par(mar = c(1, 4.5, 1, 3))
barplot(num_features,
    col = leg_solvent,
    ylab = "Number of features", space = 0.05)
barplot(colSums(missing_values),
        ylab = "Number of missing values", col = leg_solvent, space = 0.05)
boxplot(intensity, 
        ylab = "Log2 intensity", col = leg_solvent, space = 0.05)

cpt <- paste0("Distribution of RSD values across samples for the ",
              "normalized data for each solvent type.")
pandoc.table(res_df, style = "rmarkdown", caption = cpt)

#grid.table(signif(res_df, digits = 4))
```

- Noise comparison: we will compare the amount of noise between the solvents.

```{r}
# overall signal in the dataset 
#' - for each file calculate the sum of intensities 
background  <- spectra(full) |>
    split(fromFile(full)) |>
    lapply(tic) |>
    lapply(sum) |>
    unlist()

# Overall signal that is in the chromatographic peaks detection 
    # - check "into" definition first, mioght need to multiply it by something
detected <- apply(assay(res_full), 2, function(x) sum(x, na.rm = TRUE))

# substract and plot ? Also i'm removing blanks bc i think we don't need it 
names(background) <- names(detected) <- res_full$solvent
#remove blanks
noise <- background[!idx] - detected[!idx]

f <- factor(names(noise), levels = unique(names(noise)))
group <- split(noise, f)

plot(NULL, xlim = c(1, length(group)), ylim = range(unlist(group)), 
     xaxt = "n", xlab = "Solvents", ylab = "Noise", 
     main = "Noise comparison between solvents")
for (i in seq_along(group)) {
  points(rep(i, length(group[[i]])), group[[i]], pch = 19, col = leg_solvent[i])
}
axis(1, at = seq_along(group), labels = names(group))
```

- number of features / intensity per rt slices 

```{r fig.height=8, fig.width=8}
# Bin features per RT slices
vc <- featureDefinitions(full)$rtmed
breaks <- seq(0, max(vc, na.rm = TRUE) + 1, length.out = 10) |> 
    round(0)
cuts <- cut(vc, breaks = breaks, include.lowest = TRUE)

# Number of features per RT slice for each solvent
fts_solvents <- list(MEOH_H2O = MEOH_H2O,
                 MEOH = MEOH,
                 ACN = ACN,
                 ACN_MEOH = ACN_MEOH)

num_features_solvent <- lapply(fts_solvents, function(x) table(cuts[x]))

ftc <-function(solvent_idx, fts_idx) {
    tmp <- rowSums(assay(res_full, "norm")[, solvent_idx], na.rm = TRUE)
    tmp <- tmp[fts_idx]
    cuts_tmp <- cuts[fts_idx]
    t <- split(tmp, cuts_tmp) |> 
        lapply(sum, na.rm = TRUE, simplify = TRUE)
    res <- unsplit(t, names(t))
    names(res) <- names(t)
    res
}

intensity_solvent <- list(
    MetOH_H20 = ftc(idx_mh, MEOH_H2O),
    ACN = ftc(idx_a, ACN),
    MetOH = ftc(idx_m, MEOH),
    ACN_MetOH = ftc(idx_am, ACN_MEOH)
    )

# Transform intensity to log2 scale
intensity_solvent <- lapply(intensity_solvent, log2)

# Plot
layout(mat = matrix(1:2, ncol = 1), heights = c(0.5, 0.5))
par(mar = c(2.5, 4.5, 2, 3))

# Plot number of features
ylim_features <- c(0, max(unlist(num_features_solvent)))
plot(num_features_solvent[[1]], col = leg_solvent[1], ylab = "Number of features",
     xlab = "", type = "b", pch = 16, xaxt = "n", ylim = ylim_features,
     main = "Analysis along the RT axis for each solvent")
for (i in 2:length(num_features_solvent)) {
  lines(num_features_solvent[[i]], col = leg_solvent[i], type = "b", pch = 16)
}
axis(1, at = 1:length(num_features_solvent[[1]]), labels = FALSE)

# Plot intensity
ylim_intensity <- range(unlist(intensity_solvent))
plot(intensity_solvent[[1]], type = "b", pch = 16, xlab = "Retention time",
     ylab = "Intensity", col = leg_solvent[1], xaxt = "n", ylim = ylim_intensity)
for (i in 2:length(intensity_solvent)) {
  lines(intensity_solvent[[i]], type = "b", pch = 16, col = leg_solvent[i])
}
axis(1, at = 1:length(intensity_solvent[[1]]), labels = names(intensity_solvent[[1]]), las = 1, cex.axis = 0.8)
legend("top", legend = names(intensity_solvent), col = leg_solvent, pch = 16, cex = 1, horiz = TRUE, bty = "n")


# par for both and grid, 
```

- meadians of the medians

```{r fig.height=8, fig.width=8}
ftc <-function(solvent_idx, fts_idx) {
    tmp <- rowMedians(assay(res_full, "norm")[, solvent_idx], na.rm = TRUE)
    tmp <- tmp[fts_idx]
    cuts_tmp <- cuts[fts_idx]
    t <- split(tmp, cuts_tmp) |> 
        lapply(median, na.rm = TRUE, simplify = TRUE)
    res <- unsplit(t, names(t))
    names(res) <- names(t)
    res
}

intensity_solvent <- list(
    MetOH_H20 = ftc(idx_mh, MEOH_H2O),
    ACN = ftc(idx_a, ACN),
    MetOH = ftc(idx_m, MEOH),
    ACN_MetOH = ftc(idx_am, ACN_MEOH)
    )

# Transform intensity to log2 scale
intensity_solvent <- lapply(intensity_solvent, log2)

# Plot
layout(mat = matrix(1:2, ncol = 1), heights = c(0.5, 0.5))
par(mar = c(2.5, 4.5, 2, 3))

# Plot number of features
ylim_features <- c(0, max(unlist(num_features_solvent)))
plot(num_features_solvent[[1]], col = leg_solvent[1], ylab = "Number of features",
     xlab = "", type = "b", pch = 16, xaxt = "n", ylim = ylim_features,
     main = "Analysis along the RT axis for each solvent")
for (i in 2:length(num_features_solvent)) {
  lines(num_features_solvent[[i]], col = leg_solvent[i], type = "b", pch = 16)
}
axis(1, at = 1:length(num_features_solvent[[1]]), labels = FALSE)

# Plot intensity
ylim_intensity <- range(unlist(intensity_solvent))
plot(intensity_solvent[[1]], type = "b", pch = 16, xlab = "Retention time",
     ylab = "Intensity", col = leg_solvent[1], xaxt = "n", ylim = ylim_intensity)
for (i in 2:length(intensity_solvent)) {
  lines(intensity_solvent[[i]], type = "b", pch = 16, col = leg_solvent[i])
}
axis(1, at = 1:length(intensity_solvent[[1]]), labels = names(intensity_solvent[[1]]), las = 1, cex.axis = 0.8)
legend("top", legend = names(intensity_solvent), col = leg_solvent, pch = 16, cex = 1, horiz = TRUE, bty = "n")
```

- sum of the medians

```{r fig.height=8, fig.width=8}
ftc <-function(solvent_idx, fts_idx) {
    tmp <- rowMedians(assay(res_full, "norm")[, solvent_idx], na.rm = TRUE)
    tmp <- tmp[fts_idx]
    cuts_tmp <- cuts[fts_idx]
    t <- split(tmp, cuts_tmp) |> 
        lapply(sum, na.rm = TRUE, simplify = TRUE)
    res <- unsplit(t, names(t))
    names(res) <- names(t)
    res
}

intensity_solvent <- list(
    MetOH_H20 = ftc(idx_mh, MEOH_H2O),
    ACN = ftc(idx_a, ACN),
    MetOH = ftc(idx_m, MEOH),
    ACN_MetOH = ftc(idx_am, ACN_MEOH)
    )

# Transform intensity to log2 scale
intensity_solvent <- lapply(intensity_solvent, log2)

# Plot
layout(mat = matrix(1:2, ncol = 1), heights = c(0.5, 0.5))
par(mar = c(2.5, 4.5, 2, 3))

# Plot number of features
ylim_features <- c(0, max(unlist(num_features_solvent)))
plot(num_features_solvent[[1]], col = leg_solvent[1], ylab = "Number of features",
     xlab = "", type = "b", pch = 16, xaxt = "n", ylim = ylim_features,
     main = "Analysis along the RT axis for each solvent")
for (i in 2:length(num_features_solvent)) {
  lines(num_features_solvent[[i]], col = leg_solvent[i], type = "b", pch = 16)
}
axis(1, at = 1:length(num_features_solvent[[1]]), labels = FALSE)

# Plot intensity
ylim_intensity <- range(unlist(intensity_solvent))
plot(intensity_solvent[[1]], type = "b", pch = 16, xlab = "Retention time",
     ylab = "Intensity", col = leg_solvent[1], xaxt = "n", ylim = ylim_intensity)
for (i in 2:length(intensity_solvent)) {
  lines(intensity_solvent[[i]], type = "b", pch = 16, col = leg_solvent[i])
}
axis(1, at = 1:length(intensity_solvent[[1]]), labels = names(intensity_solvent[[1]]), las = 1, cex.axis = 0.8)
legend("top", legend = names(intensity_solvent), col = leg_solvent, pch = 16, cex = 1, horiz = TRUE, bty = "n")
```

- overlap of features between solvents

```{r}
# Create a data frame for the UpSet plot
upset_df <- lapply(fts_solvents, as.integer)

# Plot the UpSet plot
library(UpSetR)
upset(data.frame(upset_df), sets = c("MEOH_H2O", "ACN", "MEOH", "ACN_MEOH"), sets.bar.color = leg_solvent)
```


```{r}
save(res_full, file = paste0(dir, "SumExp_full_normalisation.RData"))
```

# MS/MS annotation 

```{r}
# these need to be from the same file system
full@spectra$file_index <- fromFile(full)
```

First need to prep spectra input 

```{r prep spectra}
## dataset 
# get spectra data and change their backend 
full_spectra <- featureSpectra(full, msLevel = 2L)
full_spectra <- setBackend(full_spectra, MsBackendMemory())

#' Remove peaks with an intensity below 5% or the spectra's BPC
low_int <- function(x, ...) {
    x > max(x, na.rm = TRUE) * 0.05
}
full_spectra <- filterIntensity(full_spectra, intensity = low_int)

length(full_spectra)
full_spectra$feature_id |>
    table() |>
    quantile()

full_spectra |>
    lengths() |>
    quantile()

#' Remove peaks with an m/z > the precursor m/z. For single-charged ions
#' no fragment peak can have an m/z >= the precursor 
full_spectra <- full_spectra |>
    filterPrecursorPeaks(mz = "==", ppm = 50)

#' Remove spectra with a single peak.
full_spectra <- full_spectra[lengths(full_spectra) > 1]

#' Add Spectra index 
full_spectra$spectra_idx <- seq_len(length(full_spectra))

#' Apply processing
full_spectra <- applyProcessing(full_spectra)
```

```{r}
## database 
library(AnnotationHub)
library(MetaboAnnotation)
library(CompoundDb)

ah <- AnnotationHub()
query(ah, "MassBank") 
mb <- ah[["AH116166"]] #updated 19.02.24

#' Get full MS2 data from MassBank 
mb <- Spectra(mb)

#' Do same filtering as for our spectra data 
mb <- filterIntensity(mb, intensity = low_int)
mb <- filterPrecursorPeaks(mb, mz = "==", ppm = 50)
mb <- mb[lengths(mb) > 1]
```

It is important to note that we are using different databases to annotate.
In the future we will try to implement the GNPS mix of databases.

You can run this code with your own database to accurately compare your results
with different softwares. 

Matching our spectra data to the database:

```{r matching}
#' remove parallel processing 
register(SerialParam())

#' Change databse backend and apply processing described earlier
mb <- setBackend(mb, MsBackendMemory())
mb <- applyProcessing(mb)

#' Matching
prm <- CompareSpectraParam(ppm = 10, requirePrecursor = TRUE,
                           THRESHFUN = function(x) which(x >= 0.8)) 
mtch_full <- matchSpectra(full_spectra, mb, param = prm)
mtch_full
#' really low percentage of MS2 spectra matched.
length(whichQuery(mtch_full)) / length(mtch_full) * 100

#' for how many features do we have MS2 spectra
length(unique(mtch_full$feature_id))
    
#' Keep only the query that got matches 
mtch_full <- mtch_full[whichQuery(mtch_full)]

#' for how many features do we have MS2 spectra WITH db matches?
length(unique(mtch_full$feature_id))

# Extract results 
md_full <- matchedData(mtch_full, c("rtime", "precursorMz", "feature_id", 
                                "target_inchikey", "target_name", "score", 
                                "target_formula", "file_index", "spectra_idx"))


save(md_full, file = paste0(dir, "md_full.RData"))
```

## remove duplciate matches (using inchikey) - keep best score

```{r echo=TRUE}
rmv_duplicate <- function(md) {
    res <- lapply(split(md, md$feature_id), function(x) {
        lapply(split(x, x$target_inchikey), function(z) {
            z[which.max(z$score), ]
        }) |>
            do.call(what = rbind)
    }) |>
        do.call(what = rbind) |>
        as.data.frame()
}

md_full <- rmv_duplicate(md_full)
```

# plot resulting compounds

```{r eval=FALSE, include=FALSE}
tmpdr <- paste0(dir, "full/annotation/")
dir.create(tmpdr, recursive = TRUE, showWarnings = FALSE)
for (i in seq_len(nrow(md_full))) {
    chrom <- featureChromatograms(full, features = md_full$feature_id[i])
    png(paste0(tmpdr, "feature_", md_full$feature_id[i], ".png"),
        width = 12, height = 8, units = "cm", res = 600, pointsize = 4)
    plot(chrom, main = paste0(md_full$target_name[i], ": ", md_full$feature_id[i]),
         col = paste0(col_sample, 80), 
         peakBg = paste0(col_sample[chromPeaks(chrom)[, "sample"]], 40))
    grid()
    legend("topright", col = leg_sample,
           legend = names(leg_sample), lty = 1)
    abline(v = md_full$rtime[i], col = "red", lty = 3)
    dev.off()
}
```

# Separate blanks 

```{r}
full_blank <- full[sampleData(full)$sample_role == "Blank", keepFeatures = TRUE]
full <- full[sampleData(full)$sample_role != "Blank", keepFeatures = TRUE]

res_full_blank <- res_full[, res_full$sample_role == "Blank"]
res_full <- res_full[, res_full$sample_role != "Blank"]
```

# Comparison on annotated data 

```{r echo=TRUE}
# Bind annotation data with feature values and possible contaminant flag
fts_def <- featureDefinitions(full)[md_full$feature_id, 
                                    c("MEOH_H2O", "MEOH", "ACN", "ACN_MEOH", 
                                      "possible_contaminants")]
md_full <- cbind(md_full, fts_def)
# some NA because no blank signal: replace by FALSE
md_full$possible_contaminants[is.na(md_full$possible_contaminants)] <- FALSE 
md_full$possible_contaminants <- as.logical(md_full$possible_contaminants)

# Create a annotation list with no  feature doublets - just to evaluate 
# contaminants and non contaminants

unique_fts <- split(md_full, md_full$feature_id) |>
    lapply(function(x) {
        x[which.max(x$score), ]
    }) |> 
    do.call(what = rbind) |>
    as.data.frame()

MEOH <- unique_fts$MEOH >= 2 & unique_fts$possible_contaminants == TRUE
MEOH_H2O <- unique_fts$MEOH_H2O >= 2 & unique_fts$possible_contaminants == TRUE
ACN <- unique_fts$ACN >= 2 & unique_fts$possible_contaminants == TRUE
ACN_MEOH <- unique_fts$ACN_MEOH >= 2 & unique_fts$possible_contaminants == TRUE

# Summary compare amount of cont. between solvent
list_cont <- c(sum(MEOH_H2O), sum(ACN), sum(MEOH), sum(ACN_MEOH))

# Create the bar plot
barplot(list_cont,
        names.arg = names(leg_solvent),
        col = leg_solvent,
        xlab = "Solvents",
        ylab = "Number of annotated features",
        main = paste0("Number of annotated features that are contamination ",
        "from solvent"))
```

```{r fig.height=8, fig.width=6}
# Take non-contaminated features 
MEOH <- unique_fts$MEOH >= 2 & unique_fts$possible_contaminants == FALSE
MEOH_H2O <- unique_fts$MEOH_H2O >= 2 &
    unique_fts$possible_contaminants == FALSE
ACN <- unique_fts$ACN >= 2 & unique_fts$possible_contaminants == FALSE
ACN_MEOH <- unique_fts$ACN_MEOH >= 2 & 
    unique_fts$possible_contaminants == FALSE

# Define the number of annotated features for each solvent
num_compounds <- c(sum(MEOH_H2O), sum(ACN), sum(MEOH), sum(ACN_MEOH))

res_mh <- res_full[, res_full$solvent == "MEOH_H2O"]
res_m <- res_full[, res_full$solvent == "MEOH"]
res_a <- res_full[, res_full$solvent == "ACN"]
res_am <- res_full[, res_full$solvent == "ACN_MEOH"]

fts <- unique_fts$feature_id # allows to remove bias due to doublet in annotation

# Compute Rsds and quantiles on annotated data per solvent
CV_df <- cbind(
    MetOH_H2O = rowRsd(assay(res_mh, "norm")[fts, ], na.rm = TRUE, mad = TRUE),
    ACN = rowRsd(assay(res_a, "norm")[fts, ], na.rm = TRUE, mad = TRUE),
    MetOH = rowRsd(assay(res_m, "norm")[fts, ], na.rm = TRUE, mad = TRUE),
    ACN_MetOH = rowRsd(assay(res_am, "norm")[fts, ], na.rm = TRUE, mad = TRUE))

res_df <- data.frame(
    MetOH_H2O = quantile(CV_df[, "MetOH_H2O"], na.rm = TRUE),
    ACN = quantile(CV_df[, "ACN"], na.rm = TRUE),
    MetOH = quantile(CV_df[, "MetOH"], na.rm = TRUE),
    ACN_MetOH = quantile(CV_df[, "ACN_MetOH"], na.rm = TRUE)
)

# Extract intensity for annotated data per solvent
intensity <- cbind(
    MetOH_H2O = log2(as.numeric(assay(res_mh, "norm")[fts, ])),
    ACN = log2(as.numeric(assay(res_a, "norm")[fts, ])),
    MetOH = log2(as.numeric(assay(res_m, "norm")[fts, ])),
    AVN_MetOH = log2(as.numeric(assay(res_am, "norm")[fts, ])))

# Calculate amount of missing values per solvent
missing_values <- cbind(
    MetOH_H2O = rowSums(is.na(assay(res_mh, "raw")[fts, ])),
    ACN = rowSums(is.na(assay(res_a, "raw")[fts, ])),
    MetOH = rowSums(is.na(assay(res_m, "raw")[fts, ])),
    ACN_MetOH = rowSums(is.na(assay(res_am, "raw")[fts, ])))

#General summary plot combining data above 
layout(mat = matrix(1:3, ncol = 1), height = c(0.3, 0.3, 0.8))
par(mar = c(1, 4.5, 1, 3))
barplot(num_compounds,
    col = leg_solvent,
    ylab = "Number of annotated feature", space = 0.05)
barplot(colSums(missing_values),
        ylab = "Number of missing values", col = leg_solvent, space = 0.05)
boxplot(intensity, 
        ylab = "Log2 intensity", col = leg_solvent, space = 0.05)

cpt <- paste0("Distribution of RSD values across samples for the ",
              "annotated compounds for each solvent type.")
pandoc.table(res_df, style = "rmarkdown", caption = cpt)

# to save the Rsd table - run in command line: 
#grid.table(signif(res_df, digits = 4))
```

- distribution along the retention time axis 

```{r fig.height=8, fig.width=8}
#idx for each solvent
idx_mh <- sampleData(full)$solvent == "MEOH_H2O"
idx_m <- sampleData(full)$solvent == "MEOH"
idx_a <- sampleData(full)$solvent == "ACN"
idx_am <- sampleData(full)$solvent == "ACN_MEOH"

#need annotated features names for each solvent 
fts_solvents <- list(MEOH_H2O = unique(md_full$feature_id[MEOH_H2O]),
                 MEOH = unique(md_full$feature_id[MEOH]),
                 ACN = unique(md_full$feature_id[ACN]),
                 ACN_MEOH = unique(md_full$feature_id[ACN_MEOH]))

# get indice form the full dataset
fts_solvents <- lapply(fts_solvents, function(x) rownames(featureDefinitions(full)) %in% x)

num_features_solvent <- lapply(fts_solvents, function(x) table(cuts[x]))

ftc <-function(solvent_idx, fts_idx) {
    tmp <- rowSums(assay(res_full, "norm")[, solvent_idx], na.rm = TRUE)
    tmp <- tmp[fts_idx]
    cuts_tmp <- cuts[fts_idx]
    t <- split(tmp, cuts_tmp) |> 
        lapply(sum, na.rm = TRUE, simplify = TRUE)
    res <- unsplit(t, names(t))
    names(res) <- names(t)
    res
}

intensity_solvent <- list(
    MetOH_H20 = ftc(idx_mh, fts_solvents$MEOH_H2O),
    ACN = ftc(idx_a, fts_solvents$ACN),
    MetOH = ftc(idx_m, fts_solvents$MEOH),
    ACN_MetOH = ftc(idx_am, fts_solvents$ACN_MEOH)
    )

# Transform intensity to log2 scale
intensity_solvent <- lapply(intensity_solvent, log2)

# Plot
layout(mat = matrix(1:2, ncol = 1), heights = c(0.5, 0.5))
par(mar = c(2.5, 4.5, 2, 3))

# Plot number of features
ylim_features <- c(0, max(unlist(num_features_solvent)))
plot(num_features_solvent[[1]], col = leg_solvent[1], ylab = "Number of features",
     xlab = "", type = "b", pch = 16, xaxt = "n", ylim = ylim_features,
     main = "Analysis along the RT axis for each solvent")
for (i in 2:length(num_features_solvent)) {
  lines(num_features_solvent[[i]], col = leg_solvent[i], type = "b", pch = 16)
}
axis(1, at = 1:length(num_features_solvent[[1]]), labels = FALSE)

# Plot intensity
ylim_intensity <- range(unlist(intensity_solvent))
plot(intensity_solvent[[1]], type = "b", pch = 16, xlab = "Retention time",
     ylab = "Intensity", col = leg_solvent[1], xaxt = "n", ylim = ylim_intensity)
for (i in 2:length(intensity_solvent)) {
  lines(intensity_solvent[[i]], type = "b", pch = 16, col = leg_solvent[i])
}
axis(1, at = 1:length(intensity_solvent[[1]]), labels = names(intensity_solvent[[1]]), las = 1, cex.axis = 0.8)
legend("top", legend = names(intensity_solvent), col = leg_solvent, pch = 16, cex = 1, horiz = TRUE, bty = "n")
```

- medians of the medians

```{r fig.height=8, fig.width=8}
ftc <-function(solvent_idx, fts_idx) {
    tmp <- rowMedians(assay(res_full, "norm")[, solvent_idx], na.rm = TRUE)
    tmp <- tmp[fts_idx]
    cuts_tmp <- cuts[fts_idx]
    t <- split(tmp, cuts_tmp) |> 
        lapply(median, na.rm = TRUE, simplify = TRUE)
    res <- unsplit(t, names(t))
    names(res) <- names(t)
    res
}

intensity_solvent <- list(
    MetOH_H20 = ftc(idx_mh, fts_solvents$MEOH_H2O),
    ACN = ftc(idx_a, fts_solvents$ACN),
    MetOH = ftc(idx_m, fts_solvents$MEOH),
    ACN_MetOH = ftc(idx_am, fts_solvents$ACN_MEOH)
    )

# Transform intensity to log2 scale
intensity_solvent <- lapply(intensity_solvent, log2)

# Plot
layout(mat = matrix(1:2, ncol = 1), heights = c(0.5, 0.5))
par(mar = c(2.5, 4.5, 2, 3))

# Plot number of features
ylim_features <- c(0, max(unlist(num_features_solvent)))
plot(num_features_solvent[[1]], col = leg_solvent[1], ylab = "Number of features",
     xlab = "", type = "b", pch = 16, xaxt = "n", ylim = ylim_features,
     main = "Analysis along the RT axis for each solvent")
for (i in 2:length(num_features_solvent)) {
  lines(num_features_solvent[[i]], col = leg_solvent[i], type = "b", pch = 16)
}
axis(1, at = 1:length(num_features_solvent[[1]]), labels = FALSE)

# Plot intensity
ylim_intensity <- range(unlist(intensity_solvent), na.rm = TRUE)
plot(intensity_solvent[[1]], type = "b", pch = 16, xlab = "Retention time",
     ylab = "Intensity", col = leg_solvent[1], xaxt = "n", ylim = ylim_intensity)
for (i in 2:length(intensity_solvent)) {
  lines(intensity_solvent[[i]], type = "b", pch = 16, col = leg_solvent[i])
}
axis(1, at = 1:length(intensity_solvent[[1]]), labels = names(intensity_solvent[[1]]), las = 1, cex.axis = 0.8)
legend("top", legend = names(intensity_solvent), col = leg_solvent, pch = 16, cex = 1, horiz = TRUE, bty = "n")
```

- overlap of annotated data 

```{r}
# annotated list if you want
library(UpSetR)

# Use the annotated data bit unqiue features generated before. Here instead we
# should probably have a list of the annotated compounds that you guys curate. 

MEOH <- unique_fts$MEOH >= 2 
MEOH_H2O <- unique_fts$MEOH_H2O >= 2 
ACN <- unique_fts$ACN >= 2 
ACN_MEOH <- unique_fts$ACN_MEOH >= 2 

# Create a data frame for the UpSet plot
upset_df <- data.frame(
  MEOH_H2O = as.integer(MEOH_H2O),
  ACN = as.integer(ACN),
  MEOH = as.integer(MEOH),
  ACN_MEOH = as.integer(ACN_MEOH)
)

# Plot the UpSet plot
upset(upset_df, sets = c("MEOH_H2O", "ACN", "MEOH", "ACN_MEOH"), 
      sets.bar.color = leg_solvent)
```


```{r}
fts <- md_full$feature_id
Summary_table <- cbind(md_full[, c("feature_id", "rtime", "precursorMz", "target_name")], 
                       CV_MetOH_H2O = rowRsd(assay(res_mh, "norm")[fts, ], na.rm = TRUE, mad = TRUE),
                       CV_MetOH = rowRsd(assay(res_m, "norm")[fts, ], na.rm = TRUE, mad = TRUE),
                       CV_ACN = rowRsd(assay(res_a, "norm")[fts, ], na.rm = TRUE, mad = TRUE),
                       CV_ACN_MetOH = rowRsd(assay(res_am, "norm")[fts, ], na.rm = TRUE, mad = TRUE),
                       Average_int_MetOH_H2O = rowMeans(assay(res_mh, "norm")[fts, ], na.rm = TRUE),
                       Average_int_MetOH = rowMeans(assay(res_m, "norm")[fts, ], na.rm = TRUE),
                       Average_int_ACN = rowMeans(assay(res_a, "norm")[fts, ], na.rm = TRUE),
                       Average_int_ACN_MetOH = rowMeans(assay(res_am, "norm")[fts, ], na.rm = TRUE),
                       Missing_values_MetOH_H2O = rowSums(is.na(assay(res_mh, "raw")[fts, ])),
                       Missing_values_MetOH = rowSums(is.na(assay(res_m, "raw")[fts, ])),
                       Missing_values_ACN = rowSums(is.na(assay(res_a, "raw")[fts, ])),
                       Missing_values_ACN_MetOH = rowSums(is.na(assay(res_am, "raw")[fts, ]))) |>
    as.data.frame()
                       
cpt <- paste0("Summary table of the annotated compounds for each solvent type.")
pandoc.table(head(Summary_table), style = "rmarkdown", caption = cpt, split.tables = 150)
write.csv(Summary_table, file = paste0(dir, "Summary_table_DBS.csv"))
```

## Annex checking if your annotated compounds are contamination 

Compound i will check:
- 2,2'-(Tetradecylimino)diethanol 
- Hexamethylphosphoramide

You can easily adjust the code to do it with other compounds.

```{r fig.height=10, fig.width=12}
# 2,2'-(Tetradecylimino)diethanol
m <- compounds[compounds$Metabolite_Name == "2,2'-(Tetradecylimino)diethanol",]

# Extract all MS2 spectra in that area 
spectra <- filterRanges(full_spectra, # MS2 spectra object from before
                        spectraVariables = c("rtime", "precursorMz"), 
                        ranges = c(m$rtmin, m$rtmax, m$mzmin, m$mzmax))

# Building similarity matrix 
sim_matrix <- compareSpectra(spectra)
vec <- spectra$file_index
vec[vec %in% c(1:4)] <- "blank"
vec[vec %in% c(5:16)] <- "study"

# Creating heatmap data
ann <- data.frame(sample_type = vec)
rownames(ann) <- rownames(sim_matrix)
col_sample <- c("blank" = "orange", "study" = "grey")

#' plot the heatmap
pheatmap(sim_matrix, annotation_col = ann , 
         annotation_colors = list(sample_type = col_sample), 
         show_rownames = FALSE, show_colnames = FALSE , 
         main = "2,2'-(Tetradecylimino)diethanol")
```


```{r}
# Hexamethylphosphoramide
m <- compounds[compounds$Metabolite_Name == "Hexamethylphosphoramide",]

# Extract all MS2 spectra in that area
spectra_H <- filterRanges(full_spectra, 
                          spectraVariables = c("rtime", "precursorMz"), 
                          ranges = c(m$rtmin, m$rtmax, m$mzmin, m$mzmax))

vec <- spectra_H$file_index
vec[vec %in% c(1:4)] <- "blank"
vec[vec %in% c(5:16)] <- "study"

sim_matrix <- compareSpectra(spectra_H)
ann <- data.frame(sample_type = vec)
rownames(ann) <- rownames(sim_matrix)
col_sample <- c("blank" = "orange", "study" = "grey")

#' plot the heatmap
pheatmap(sim_matrix, annotation_col = ann ,
         annotation_colors = list(sample_type = col_sample), 
         main = "Hexamethylphosphoramide", show_rownames = FALSE, 
         show_colnames = FALSE)
```


